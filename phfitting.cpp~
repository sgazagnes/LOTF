
#include <iostream>
#include <set>
#include <sstream>
#include <algorithm>
#include  <cmath>
#include <fstream>
#include <vector>
#include <gsl/gsl_poly.h>
#include <cstdlib>
#include <stdlib.h> 
// Root headers
#include "TFile.h"
#include "TNtuple.h"
#include "TStopwatch.h"
#include "TH1.h"

#include "simon_functions.h"
#include "logc.h"
#include "path_queue.h"




double nodeDistanceToLinearFit(double xdet, double ydet, double *x_coef, double *y_coef){
  
  //double xdet = (double) node->m_r/  sqrt( 2*pow(40,2));//node->m_xDet;
  //double ydet = (double)  (node->m_thetaDeg+180.) /360.;

  double newx_coef[2] = {x_coef[0] - xdet, x_coef[1]};
  double newy_coef[2] = {y_coef[0] - ydet, y_coef[1]};

  double vectortanx[2] = {x_coef[1], 0.};
  double vectortany[2] = {y_coef[1], 0.};
	      
  double d[3] = {newx_coef[0]*vectortanx[0] + newy_coef[0]*vectortany[0],
		 newx_coef[0]*vectortanx[1] + newx_coef[1]*vectortanx[0] +
		 newy_coef[0]*vectortany[1] + newy_coef[1]*vectortany[0],
		 newx_coef[1]*vectortanx[1] + newy_coef[1]*vectortany[1]  };

  double x0[2];
  int nroot = gsl_poly_solve_quadratic(d[2], d[1], d[0], x0, x0+1);

  double xIntersect, yIntersect, currDist;
      
  if(nroot ==1){
    xIntersect = gsl_poly_eval(x_coef, 2, x0[0]);
    yIntersect = gsl_poly_eval(y_coef, 2, x0[0]);
    currDist = sqrt(pow(xIntersect - xdet,2) + pow(yIntersect - ydet,2));
  }

		
  for (int j = 0; j < nroot; j++){
    double newx = gsl_poly_eval(x_coef, 2, x0[j]);
    double newy = gsl_poly_eval(y_coef, 2, x0[j]);
    double newdist = sqrt(pow(newx - xdet,2) + pow(newy - ydet,2));
    if(j == 0){
      xIntersect = newx;
      yIntersect = newy;
      currDist = newdist;
    } else if( currDist > newdist) {
      xIntersect = newx;
      yIntersect = newy;
      currDist = newdist;
    }
  }

  return currDist;
}


double nodeDistanceToQuadFit(double xdet, double ydet, double *x_coef, double *y_coef){

  double newx_coef[3] = {x_coef[0] - xdet, x_coef[1], x_coef[2]};
  double newy_coef[3] = {y_coef[0] - ydet, y_coef[1], y_coef[2]};

  double vectortanx[3] = {x_coef[1], 2*x_coef[2], 0.};
  double vectortany[3] = {y_coef[1], 2*y_coef[2], 0.};
	      
  double d[4] = {newx_coef[0]*vectortanx[0] + newy_coef[0]*vectortany[0],
		 newx_coef[0]*vectortanx[1] + newx_coef[1]*vectortanx[0] +
		 newy_coef[0]*vectortany[1] + newy_coef[1]*vectortany[0],
		 newx_coef[0]*vectortanx[2] + newx_coef[1]*vectortanx[1] + newx_coef[2]*vectortanx[0] +
		 newy_coef[0]*vectortany[2] + newy_coef[1]*vectortany[1] + newy_coef[2]*vectortany[0],
		 newx_coef[2]*vectortanx[1] + newy_coef[2]*vectortany[1]};

  double x0[3];
  int nroot = gsl_poly_solve_cubic(d[2]/d[3], d[1]/d[3], d[0]/d[3], x0, x0+1, x0+2);

  //debug("Polynomial coeff : %lf + %lf x + %lf x^2 + %lf x^3", d[0], d[1], d[2], d[3]);
  //	debug("Real roots %d : x1 = %lf x2 =  %lf x3 =  %lf \n\n", nroot, x0[0], x0[1], x0[2]);

  double xIntersect, yIntersect, currDist = -1;
  if(nroot ==1){
    xIntersect = gsl_poly_eval(x_coef, 3, x0[0]);
    yIntersect = gsl_poly_eval(y_coef, 3, x0[0]);
    currDist = sqrt(pow(xIntersect - xdet,2) + pow(yIntersect - ydet,2));
  }

		
  for (int j = 0; j < nroot; j++){
    double newx = gsl_poly_eval(x_coef, 3, x0[j]);
    double newy = gsl_poly_eval(y_coef, 3, x0[j]);
    double newdist = sqrt(pow(newx - xdet,2) + pow(newy - ydet,2));
    if(j == 0){
      xIntersect = newx;
      yIntersect = newy;
      currDist = newdist;
    } else if( currDist > newdist) {
      xIntersect = newx;
      yIntersect = newy;
      currDist = newdist;
    }
  }
  return currDist;
}

   
/* fitNextId */

int fitNextId(CoordGrid &gr, std::vector< GridNode > &Ingrid, PathCandidate &cand, std::vector<int> &next, int k){
  
  // std::vector< GridNode > &Ingrid = gr.m_grid;
  int goodId     = -1;
  int method;
  int degree, nElts;
  std::vector<double> x =  std::vector<double>( cand.m_x );
  std::vector<double> y =  std::vector<double>( cand.m_y ); 
  std::vector<double> r =  std::vector<double>( cand.m_r );
  std::vector<double> theta =  std::vector<double>( cand.m_theta ); 

  for (int i = 0; i <x.size(); i++){
    r[i] /= sqrt( 2*pow(40,2));
    theta[i] = (theta[i]+180.) /360.;    
  }
  double prevtheta = theta.back();

  //x.erase(std::remove(x.begin(), x.end(), -1), x.end());
  // y.erase(std::remove(y.begin(), y.end(), -1), y.end());
  // r.erase(std::remove(r.begin(), r.end(), -1), r.end());
  // theta.erase(std::remove(theta.begin(), theta.end(), -1), theta.end());
  
  if(k == 0){
    std::reverse(x.begin(),x.end());
    std::reverse(y.begin(),y.end());
    std::reverse(r.begin(),r.end());
    std::reverse(theta.begin(),theta.end());
  }

  //debug("Fast-checking unphysical neighbors");

  std::vector<int> plausible;
  std::vector<int> uncertain;
  std::vector<int> unlikely;
  std::vector<int> *tocheck;

  float tol = 90.;
  for (int i = 0; i <next.size(); i++){
    int curId = next[i];
    int curIdx = gr.Find(curId);
    GridNode *node = &Ingrid[curIdx];
    double xdet = node->m_x;
    double ydet = node->m_y;
    //   dbgfit("%d", curId);
    if(node->m_type == GridNode::VIRTUAL_NODE){

      GridNode *neigh = &Ingrid[gr.Find(node->m_neighbors[0])];
      //    info("here %d, %d", neigh->m_detID,neigh->m_cm.size());

      if(neigh->m_cm.size()>0 && std::find(neigh->m_cm.begin(), neigh->m_cm.end(), cand.m_id) != neigh->m_cm.end()){
	neigh = &Ingrid[gr.Find(node->m_neighbors[1])];
      }
      if(neigh->m_cm.size() > 0 && neigh->m_cm[0] == cand.m_id){
	//error("All belong to track ?");
	continue;	
      }
      
      dbgfit("Replacing node %d with %d, and recorrecting the impact coordinates", node->m_detID, neigh->m_detID);
      PointsLineIntersectLive( *neigh, x[x.size()-1], node->m_xDet,
			   y[y.size()-1], node->m_yDet); //Output 
      node = neigh;
      xdet = node->m_x;
      ydet = node->m_y;
      if(cand.isInCandidate(node->m_detID))
	 continue;
    }
	
    // dbgfit("%d", curId);
 

    double rdet = (double) node->m_r /  sqrt( 2*pow(40,2));
    double thetadet = (double) (node->m_thetaDeg+180.) /360.;
    if(node->m_type == GridNode::STT_TYPE_SKEW)
      tol = 50;
    if(thetadet > 0.85 && prevtheta < 0.15)
      thetadet -= 1;
    else if(thetadet < 0.15 && prevtheta > 0.85)
      thetadet += 1.;
    // dbgfit("Points %lf, %lf \t %lf, %lf \t %lf, %lf",r[r.size()-2], r[r.size()-1], rdet, theta[theta.size()-2], theta[theta.size()-1], thetadet);
    float angle_r = returnAngle(r[r.size()-2], r[r.size()-1], rdet, theta[theta.size()-2], theta[theta.size()-1], thetadet);
    
    float angle_xy = returnAngle(x[x.size()-2], x[x.size()-1], xdet, y[y.size()-2], y[y.size()-1], ydet);
    // dbgfit("Points %lf, %lf %lf, \t %lf %lf, %lf",x[x.size()-2], x[x.size()-1], xdet, y[y.size()-2], y[y.size()-1], ydet);
    // dbgfit("Angle with %d is %f, %f", node->m_detID, angle_r, angle_xy);
    //    fabs(angle_r) > 85 && fabs(angle_xy) > tol &&
     if( std::find(plausible.begin(), plausible.end(), node->m_detID) == plausible.end()) 
	plausible.push_back(node->m_detID);
	// else if((fabs(angle_r) > 85 || fabs(angle_xy) > tol) && fabs(angle_r) > 50 && fabs(angle_xy) > 50 && std::find(uncertain.begin(), uncertain.end(), node->m_detID) == uncertain.end())
     //	uncertain.push_back(node->m_detID);
	// else if(  std::find(unlikely.begin(), unlikely.end(), node->m_detID) == unlikely.end())
	// unlikely.push_back(node->m_detID);
  }

  /* if(plausible.size() == 1){
    goodId = plausible[0];
    dbgfit("Only one good choice %d", goodId);
    return goodId;
    }else */
  if(plausible.size() > 0){
    dbgfit("We found %d promising candidates", plausible.size());
    tocheck = &plausible;
  }  else if (uncertain.size() > 0) {
    if(uncertain.size() == 1){
      
      goodId = uncertain[0];
      dbgfit("Only one good choice %d", goodId);
      return goodId;
    }
    dbgfit("No promising, but still possible with %d cand", uncertain.size());
    //return -1;
    tocheck = &uncertain;
  } else {
    dbgfit("Unless we want to go backwards, we should stop");
    return -1;
    }

  // Checking Track angle in polar coord 

  // debug("Points %lf, %lf \t %lf, %lf \t %lf, %lf",r[0], theta[0], r[r.size()/2], theta[theta.size()/2],r[r.size()-1], theta[theta.size()-1]);
  
  // double curv = returnCurvature(x[0], x[x.size()/2], x[x.size()-1], y[0], y[y.size()/2], y[y.size()-1]);

  // float angle = returnAngle(r[0], r[r.size()/2], r[r.size()-1],  theta[0], theta[theta.size()/2], theta[theta.size()-1]);
  //debug("Angle of track is %f", angle);
  
  //
  //if(fabs(angle) < 170){
  //   dbgfit("Quadratic Fit");
  //  method = 1;
    // degree = 2;
    // nElts  = x.size() -1;
    // } else {
  // dbgfit("Linear Fit");
  method = 0;
    degree = 1;
    nElts = x.size()-1;
    //}
 
  std::vector<double> p;
  std::vector<double> xfit;
  std::vector<double> yfit;

  double minDist = std::numeric_limits<double>::max();
    
  p.push_back(0.);
  xfit.push_back(x[ x.size()-MIN(x.size(),4)]);
  yfit.push_back(y[ y.size()-MIN(y.size(),4)]);

  for (int i = x.size()-MIN(x.size(),4), inc=0; i <  nElts; i++, inc++){ 
    //double newval = p[i] + sqrt(pow(r[i+1]-r[i],2.) + pow(theta[i+1]-theta[i],2.));
    double newval = p[inc] + sqrt(pow(x[i+1]-x[i],2.) + pow(y[i+1]-y[i],2.));

    //  dbgfit("x %f", x[i]);
    p.push_back(newval);
    xfit.push_back(x[i+1]);
    yfit.push_back(y[i+1]);
  }
  // dbgfit("r %f", r[r.size()-1]);
  // dbgfit("%lf, %lf, %lf", p[0],p[p.size()/2], p[p.size()-1]);
  dbgfit("%lf, %lf, %lf", p[0], xfit[0], yfit[0]);
  dbgfit("%lf, %lf, %lf", p[p.size()-1], x[x.size()-1], y[y.size()-1]);

  double *x_coef = polyFit(p, xfit, degree);
  double *y_coef = polyFit(p, yfit, degree);

  dbgfit("%lf, %lf", x_coef[0], x_coef[1]);
  dbgfit("%lf, %lf", y_coef[0], y_coef[1]);

  //  if(method == 0){ // linear

    
  
  for (size_t i = 0; i < tocheck->size(); i++){
    int curId = tocheck->at(i);
    int curIdx = gr.Find(curId);
    GridNode *node = &Ingrid[curIdx];
    double xdet = (double) node->m_xDet;//node->m_r/  sqrt( 2*pow(40,2));//node->m_xDet;
    double ydet = (double) node->m_yDet;// (node->m_thetaDeg+180.) /360.;     
    /*  if(ydet > 0.85 && prevtheta < 0.15)
      ydet -= 1;
    else if(ydet < 0.15 && prevtheta > 0.85)
    ydet += 1.;*/
    // double newp = p[p.size()-1] + sqrt(pow(xdet-r[r.size()-1],2.) + pow(ydet-theta[theta.size()-1],2.));
    double newp = p[p.size()-1] + sqrt(pow(xdet-x[x.size()-1],2.) + pow(ydet-y[y.size()-1],2.));
    double xest =  method == 0? x_coef[0]+x_coef[1]*newp: x_coef[0]+x_coef[1]*newp+x_coef[2]*newp*newp;
    double yest = method == 0? y_coef[0]+y_coef[1]*newp: (y_coef[0]+y_coef[1]*newp+y_coef[2]*newp*newp);
    dbgfit("%lf", newp);

    // dbgfit("Estimated new coord %lf, %lf", xest*sqrt( 2*pow(40,2)),yest*360-180);
    //  dbgfit("Node coord %lf, %lf",xdet*  sqrt( 2*pow(40,2)), ydet*360-180);
    dbgfit("Estimated new coord %lf, %lf", xest,yest);
    dbgfit("Node coord %lf, %lf",xdet, ydet);  
    //dbgfit("Distance to estimated coord is %lf", sqrt(pow(xest -xdet, 2) + pow(yest -ydet,2)));
    // double currDist = method == 0? nodeDistanceToLinearFit(xdet, ydet, x_coef, y_coef): nodeDistanceToQuadFit(xdet, ydet, x_coef, y_coef);
    double currDist =sqrt(pow(xest -xdet, 2) + pow(yest -ydet,2));// method == 0? nodeDistanceToLinearFit(xdet, ydet, x_coef, y_coef): nodeDistanceToQuadFit(xdet, ydet, x_coef, y_coef);  
     dbgfit("Node %d is at %lf", curId, currDist);
		
    if(minDist > currDist && currDist < 6){
      minDist = currDist;		  
      goodId = curId;	
    }        
  }


  
  if(goodId != -1) dbgfit("The good id is %d, and is at distance %lf", goodId,minDist);
  else dbgfit("No good ID found");
  
  return goodId;


}


   
void fittingPhase(CoordGrid &gr, std::vector< GridNode > &Ingrid, std::vector < PathCandidate* > &tracklets, std::vector<pair<int, unsigned short>> idToProcess, char *visited, int **toMergeWith){


  for(unsigned int l = 0; l < tracklets.size(); l++){ // Go for each tracklet
	
    PathCandidate &curCand = *(tracklets[l]);
    dbgfit("Track %d, status %d, length %d", curCand.m_id, curCand.m_finished,curCand.m_length);
	
    if (curCand.m_finished == 3 || curCand.m_length < 5 ) continue;

    // HEAD and TAIL nodes
    GridNode &firstNode = Ingrid[gr.Find(curCand.m_tailNode)];
    GridNode &lastNode  = Ingrid[gr.Find(curCand.m_headNode)];

    dbgfit("Tail node %d (num neigh %d),  head node %d (num neigh %d)", firstNode.m_detID, curCand.m_tailNeigh.size(), lastNode.m_detID, curCand.m_headNeigh.size());

    //We might have to fit in the tail or the head direction, check both
     for(int k = 0; k < 2; k++){ // k == 0 Tail (first node added), k == 1 Head (last node added, most often)
	int prevId = k == 1? curCand.m_headNode: curCand.m_tailNode;
	GridNode *prevNode = k == 1? &lastNode: &firstNode;

	//curent list of neighbors from previous phase
	std::vector<int> *curNeigh = k == 1? &(curCand.m_headNeigh): &(curCand.m_tailNeigh);
	// Whether the tracklets needs to be merged already
	std::vector<unsigned int> *curMerge = k == 1? &(curCand.m_toMergeHead):&(curCand.m_toMergeTail);
	std::vector<int> next;//A vector for the next nodes in the loop

	// If there is no neighbors, or if it already needs to be merged, we pass (for now)
	if(curNeigh->size() == 0){
	  dbgfit("k = %d, there is no neighbors in the list, is it consistent with the layer of the node ? %d",
		 k, prevNode->m_Layer);
	  continue;
	}

	if(curMerge->size() > 0){
	  dbgfit("This tracklets has already %d merging partner(s) in that direction ",curMerge->size() );
	  continue;
	}

	
	if (curCand.m_finished == 1){
	  continue;
	  dbgfit("We previously assumed that this track could be continued, we should check for second order neighbors in the list of %lu remaining ones", idToProcess.size());

	  for(unsigned int n = 0; n < idToProcess.size(); ++n) {
	    int testID 		= idToProcess[n].first;
	    GridNode &testNode  = Ingrid[gr.Find(testID)];
	    float currDist      = sqrt((prevNode->m_x - testNode.m_x) * (prevNode->m_x - testNode.m_x) +
				 (prevNode->m_y - testNode.m_y) * (prevNode->m_y - testNode.m_y));

	    if(currDist<5.){
	      curNeigh->push_back(testID);
	      dbgfit("Adding node %d to potential neighbors, into k %d", testID, k);	     
	    }
	  }

	  dbgfit("Let's now look into the %lu tracklets we found previously", tracklets.size());

	  for(unsigned int n = 0; n < tracklets.size(); ++n) {
	    PathCandidate &testCand = *(tracklets[n]);
	
	    if (testCand.m_finished == 3 || n == l) continue;

	    GridNode &tailNode = Ingrid[gr.Find(testCand.m_tailNode)];
	    GridNode &headNode = Ingrid[gr.Find(testCand.m_headNode)];
	    GridNode Dummy;
	    
	    double currDistTail = IntersectionPointSkeSke(gr, *prevNode, tailNode, Dummy);
	    double currDistHead = IntersectionPointSkeSke(gr, *prevNode, headNode, Dummy);
	    //dbgfit("%d %f, %d %f", tailId, currDistTail, headId, currDistHead);
	    if(currDistTail < 5. || currDistHead < 5.){
	      if(currDistTail <= currDistHead){
		curNeigh->push_back(tailNode.m_detID);
		dbgfit("Adding tail node %d to potential neighbors", tailNode.m_detID);
	      } else {
		curNeigh->push_back(headNode.m_detID);
		dbgfit("Adding head node %d to potential neighbors of head", headNode.m_detID);
	      }
	    }
	  }
	  
	} // End test if cand is status finished 2

	if(curNeigh->size() == 0){
	  dbgfit("Still no good candidate has been found");
	  continue;
	}
	
	k == 1? info("HEAD : Starting fitting next neighbors"):
	  info("TAIL : Starting fitting next neighbors");

	// Some pre-processing to reduce the number of nodes to test
	/*	for(size_t i = 0; i  < curNeigh->size(); i++){ 
	  int id = curNeigh->at(i);
	  int idx = gr.Find(id);
	  GridNode &node = Ingrid[idx];
	  if(node.m_type == GridNode::VIRTUAL_NODE){
	    //	  for (size_t j = 0; j < node.m_neighbors.size(); j++) {
	    // Remove second order neighbors from virtual
	    int neigh1 = node.m_neighbors[0];
	    int neigh2 = node.m_neighbors[1];
	    curNeigh->erase(std::remove(curNeigh->begin(), curNeigh->end(), neigh1), curNeigh->end());
	    curNeigh->erase(std::remove(curNeigh->begin(), curNeigh->end(), neigh2), curNeigh->end());	    //  }
	  }
	  }*/
	
	next.insert(next.end(),  curNeigh->begin(),  curNeigh->end());

	bool cond   = next.size() > 0? true: false;

	std::vector<int> virt;
	std::vector<int> *trk = curCand.m_memberList;

	int potCm = -1;
	int id = k == 1? trk->at(trk->size() - 2) : 1;
	GridNode &node = Ingrid[gr.Find(id)];		
	   
	// Starting the big loop

	while (cond){

	  std::vector<int> idToRemove;	
	  for(size_t i = 0; i  < next.size(); i++){ 
	    GridNode &node = Ingrid[gr.Find(next[i])];
	    if(node.m_type == GridNode::VIRTUAL_NODE){
	      // Remove second order neighbors from virtual
	      idToRemove.push_back(node.m_neighbors[0]);
	      idToRemove.push_back(node.m_neighbors[1]);
	      // dbgfit("%d", curId);

	    }
	  }
	  for(size_t i =0; i < idToRemove.size(); i++){
	    next.erase(std::remove(next.begin(), next.end(), idToRemove[i]), next.end());
	    //   next.erase(std::remove(next.begin(), next.end(), idToRemove[i]), next.end());
	  }

	  GridNode *goodNode;	    	    
	  int goodId = fitNextId(gr, Ingrid, curCand, next, k);
	    
	  if (goodId == -1) {
	    dbgfit("No good candidates have been found, stop");
	    dbgfit("Current cm %d: length is %d,  tail node %d  head node %d  Min layer %d, Max layer %d. ", curCand.m_id, curCand.m_length, curCand.m_tailNode, curCand.m_headNode, curCand.m_minLayer, curCand.m_maxLayer);
	    if((curCand.m_minLayer == 0 && curCand.m_maxLayer > 21) || (firstNode.m_LayerLimit == 1 && lastNode.m_LayerLimit == 1)){		 
	      dbgfit("track goes through all layers or makes a loop, likily finished");		 
	      curCand.m_finished = 3;		 
	    } else {
	      dbgfit("Are we missing something?");		 
	      curCand.m_finished = 2;
	    }
	    cond = false;
	    break;
	  }

	  goodNode = &Ingrid[gr.Find(goodId)];

	  //Check that we did not forget a virtual node before
	    
	  if(goodNode->m_type != GridNode::VIRTUAL_NODE){

	    /* for(size_t i = 0; i < next.size(); i++){
	      int neighId = next[i];
	      GridNode *comNode = &Ingrid[gr.Find(neighId)];
	      if(comNode->IsNeighboring(goodNode->m_detID) && (curCand.isInCandidate(comNode->m_neighbors[0]) || curCand.isInCandidate(comNode->m_neighbors[1]))){
		//if(prevNode->IsNeighboring(neighId) && comNode->m_type == GridNode::VIRTUAL_NODE){
		curCand.insertNewNode(gr, Ingrid, comNode, k == 0? curCand.m_memberList->begin(): curCand.m_memberList->end());
		visited[neighId] = 4;
	      }
	      }*/
	    for(size_t i = 0; i < goodNode->m_neighbors.size(); i++){
	      int neighId = goodNode->m_neighbors[i];
	      GridNode *comNode = &Ingrid[gr.Find(neighId)];
	      if(prevNode->IsNeighboring(neighId) && comNode->m_type == GridNode::VIRTUAL_NODE){
		curCand.insertNewNode(gr, Ingrid, &Ingrid[gr.Find(neighId)], k == 0? curCand.m_memberList->begin(): curCand.m_memberList->end());
		visited[neighId] = 1;
	      }
	    }
	  }



	  // Check if the node found belongs to an other track

	     
	  if(visited[goodId] == 1 && !goodNode->m_LayerLimit ){

	    if(goodNode->m_cm.size() > 1)
	      error("This node belongs to several tracks, we should tke care of this");
	    
	    potCm = goodNode->m_cm[0];
	    const auto p = std::find_if(tracklets.begin(), tracklets.end(),
					[potCm](const PathCandidate *obj){ return obj->m_id == potCm; } );

	    PathCandidate &neighCand = *(*p); // The CC that the node belongs to	   	   

	    //Find where the node is in the list of the other CC
	    std::vector<int>::iterator it = std::find((neighCand.m_memberList)->begin(),
						      (neighCand.m_memberList)->end(), goodId);
	    
	    int index = std::distance((neighCand.m_memberList)->begin(), it);
	    int id    = neighCand.m_memberList->at(index);
	    int dir   = 0;
	    int nextNeigh;

	    dbgfit("This node %d already belongs to a CM (%d), tail Node %d, and head Node %d", id, goodNode->m_cm[0],neighCand.m_tailNode,neighCand.m_headNode);

	    bool willMerge = neighCand.m_toMergeHead.size() == 0 && neighCand.m_toMergeTail.size() == 0? false:true;

	    dbgfit("Does this track has some merging partners? Head %lu, Tail %lu", neighCand.m_toMergeHead.size(),neighCand.m_toMergeTail.size());

	    // Check if we were already planning a merging
	    if (std::find(curCand.m_toMergeHead.begin(), curCand.m_toMergeHead.end(), goodNode->m_cm[0]) != curCand.m_toMergeHead.end() || std::find(curCand.m_toMergeTail.begin(), curCand.m_toMergeTail.end(), goodNode->m_cm[0]) != curCand.m_toMergeTail.end() ){
	      dbgfit("We were already planning to merge with this track, then let's stop here");
	      cond = false;
	      break;
	    }  

	    //Check if the node is somewhere in the middle, so it is unlikely that both tracks go together
	    if(id != neighCand.m_headNode && id != neighCand.m_tailNode){
	      dbgfit("The index is neither the tail or the head, we should continue");
	    }else{
	      
	      if(id == neighCand.m_headNode){
		dbgfit("We found a match in the tail direction");
		nextNeigh = index-1;
		dir = k == 1? 3: 1; // head to head or tail to head
		k == 1? curCand.m_toMergeHead.push_back(potCm):  curCand.m_toMergeTail.push_back(potCm);
		neighCand.m_toMergeHead.push_back(curCand.m_id);
		sayYes[curCand.m_id][potCm] = dir;
	      }

	      else if ( id == neighCand.m_tailNode ) {
		dbgfit("We found a match in the head direction");
		nextNeigh = index+1;
		dir = k == 1? 2: 0; // head to tail or tail to tail
		k == 1? curCand.m_toMergeHead.push_back(potCm):  curCand.m_toMergeTail.push_back(potCm);
		neighCand.m_toMergeTail.push_back(curCand.m_id);
		sayYes[curCand.m_id][potCm] = dir;
	      }

	      dbgfit("We shall compute some angle");

	      //Something to implement for later, we should check that the tracks are consistent
	      float angle_r = returnAngle(prevNode->m_r, goodNode->m_r, neighCand.m_r[nextNeigh], (prevNode->m_thetaDeg+180.)/360., (goodNode->m_thetaDeg+180.)/360., (neighCand.m_theta[nextNeigh]+180.)/360.);
		  
	      float angle_xy = returnAngle(prevNode->m_xDet, goodNode->m_xDet, neighCand.m_x[nextNeigh], prevNode->m_yDet, goodNode->m_yDet, neighCand.m_y[nextNeigh]);
		  
	      dbgfit("Angle r with track %f", angle_r);
	      dbgfit("Angle xy with track %f", angle_xy);
		  
	      
	      cond = false;
	      break;
	    }
	  } // End of check for node belonging to other track

	  //If we did not break before, we should then add this node to the track (head or tail depends on k)
	  curCand.insertNewNode(gr, Ingrid, goodNode, k == 0? curCand.m_memberList->begin(): curCand.m_memberList->end());
	  visited[goodId] = 1;

	  next.clear(); // Clearing the list of next nodes to check

	  /*	  for(size_t i = 0; i < next.size(); ){

	    if(curCand.isInCandidate(next[i])){
	      next.erase(std::remove(next.begin(), next.end(),next[i]), next.end());
	      continue;
	    }
	    GridNode &nextNode = Ingrid[gr.Find(next[i])];
	    
	    if(labs(nextNode.m_Layer - goodNode->m_Layer) > 1){ 
	      next.erase(std::remove(next.begin(), next.end(),next[i]), next.end());
	      continue;
	    }
	    i++;
	    }*/
	 
	  
	  //Finding next neighbors
	  for(size_t i = 0; i < goodNode->m_neighbors.size(); i++){
	      
	    int neighId = goodNode->m_neighbors[i];
	    if(curCand.isInCandidate(neighId)) continue;
	      
	    int neighIdx = gr.Find(neighId);
	    GridNode *neighNode = &Ingrid[neighIdx];

	    dbgfit("Pushing this node %d to the list", neighId );
	    next.push_back(neighId);
		
	  }

	  // If the node had a parent from an other track but we decided not to match
	  // with the track, then we should add this parent
	  
	  if(goodNode->parent != -1){
	    next.push_back(goodNode->parent);
	    dbgfit("Adding the parent node %d", goodNode->parent );
	  }

	  // If we found some neighbors, then we can continue;
	  if(next.size() > 0){	      
	    prevId = goodId;
	    prevNode = goodNode;
	    virt.clear(); // Clearing the list of virtuals that we did not use?
	    if(goodNode->m_Layer == 0){
	      dbgfit("We found neighbors but we reached the end ?, should check this");
	      curCand.m_finished = 2;
	      cond = false;
	    }			 
	  }
	  
	  else {	      
	    dbgfit("we have no more neighbors");
	    cond = false;
	      
	    //We need to find a way to check for second order neighbors

	  }
	} // END OF BIG LOOP
     } // END OF FOR = 0 or 1

     dbgfit("Finished with current tracklet");
     dbgfit("Current cm %d: length is %d,  tail node %d  head node %d  Min layer %d, Max layer %d. ", curCand.m_id, curCand.m_length, curCand.m_tailNode, curCand.m_headNode, curCand.m_minLayer, curCand.m_maxLayer);
     if((curCand.m_minLayer == 0 && curCand.m_maxLayer > 21) || (firstNode.m_LayerLimit == 1 && lastNode.m_LayerLimit == 1)){		 
       dbgfit("track goes through all layers or makes a loop, likily finished");		 
       curCand.m_finished = 3;		 
     } else {
       dbgfit("Are we missing something?");		 
       curCand.m_finished = 2;
     }

     dbgfit("Moving to next track\n");
  } // END OF ALL TRACKLETS
}
   
