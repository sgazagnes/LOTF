#include <iostream>
#include <set>
#include <sstream>
#include <algorithm>
#include  <cmath>
#include <fstream>
#include <vector>
#include <gsl/gsl_poly.h>
// Root headers
#include "TFile.h"
#include "TNtuple.h"
#include "TStopwatch.h"
#include "TH1.h"

// Local headers
#include "auxiliaryfunctions.h"
#include "CollectSttMvdPoints.h"
#include "SttMVDEventDataReader.h"
#include "pathopen.h"
#include "hitcoordinate.h"
#include "floodingFilter.h"
#include "utilfunctions.h"
#include "trackObject.h"
#include "logc.h"
#include "queue.h"
//#include "performFilter.h"
#include "pathCandidate.h"
#include "path_queue.h"





int determineSkewed_XYPlane_new( CoordGrid &hitMap, GridNode const &VNode,
                            std::vector<int> &ListOfSkewedNodesIndex,
				   std::vector<int> &ListOfVirtualNodesIndex, char *visited)
{
  info("Correcting xy-coordinates of skewed nodes for this instance for node %d", VNode.m_detID);
	    
  // Fetch all graph nodes
  std::vector< GridNode > &Ingrid = hitMap.m_grid;
  // Neighbours of the input node
  std::vector<int> const &ListOfNeighbors = VNode.m_neighbors;
  // Local variables
  int LastVirtualNodeIdx = -10;
  std::pair<float, float> Rad_deg;
  std::vector<int>::iterator FindIt;
  PathQueue SkewedNodeIndexQueue;
  // There are exactly 2 neighbours (different slopes). And there are
  // two types of virtual nodes (Ax_Vi_Sk or Sk_Vi_S).
  assert( ListOfNeighbors.size() == 2);
  int FNode_id    = ListOfNeighbors[0];//First ID
  int FNode_index = hitMap.Find(FNode_id);//First index
  GridNode &First_Neigh = Ingrid[FNode_index];
  int SNode_id    = ListOfNeighbors[1];//Second ID
  int SNode_index = hitMap.Find(SNode_id);//Second Index
  GridNode &Second_Neigh = Ingrid[SNode_index];
  // All neighbours must be active
  assert( First_Neigh.m_active && Second_Neigh.m_active );
  size_t LocalCurrentLayer, LocalNextLayer;
  LocalCurrentLayer = LocalNextLayer = 0;
  //Axial->Virtual->Skewed
  bool OuterToInner;
  if( visited[FNode_id] < 4) {
    SkewedNodeIndexQueue.inQueue(FNode_index);
    LocalCurrentLayer = First_Neigh.m_Layer;
    info("First node is %d, visited is %d, current layer %d", FNode_id,visited[FNode_id], LocalCurrentLayer);
    OuterToInner =  First_Neigh.m_Layer -  Second_Neigh.m_Layer > 0 ? true : false;
  }

  else{ 
    SkewedNodeIndexQueue.inQueue(SNode_index);
    LocalCurrentLayer = Second_Neigh.m_Layer;
    info("Second node is %d, visited is %d, current layer %d", SNode_id,visited[SNode_id], LocalCurrentLayer);
    OuterToInner =  Second_Neigh.m_Layer - First_Neigh.m_Layer  > 0 ? true : false;


  }

  info("We go in %d direction ( first %d, second %d",OuterToInner, First_Neigh.m_Layer, Second_Neigh.m_Layer);
  //LocalNextLayer = LocalCurrentLayer + 1;
  if(OuterToInner){
    if( LocalCurrentLayer > 0) {
      LocalNextLayer = LocalCurrentLayer - 1;
    }
    else{
      LocalNextLayer = 0;
    }
  }
  else{// if( !OuterToInner) {// Inner to outer
    LocalNextLayer = LocalCurrentLayer + 1;
  }
  // Process skewed node index queue
  while( !SkewedNodeIndexQueue.isEmpty() ) {
    int sk_idx = SkewedNodeIndexQueue.popFront();
    GridNode &SK_Node = Ingrid[sk_idx];
    FindIt = std::find(ListOfSkewedNodesIndex.begin(), ListOfSkewedNodesIndex.end(), sk_idx);
    if( FindIt == ListOfSkewedNodesIndex.end() ) {
      ListOfSkewedNodesIndex.push_back(sk_idx);
    }
    info("Starting with %d", SK_Node.m_detID);
    // List of neighbours
    std::vector<int> const &Neighbours = SK_Node.m_neighbors;
    for( size_t l = 0; l < Neighbours.size(); ++l) {
      int sknID  = Neighbours[l];

      int sknIdx = hitMap.Find(sknID);
      GridNode &SK_NeighNode = Ingrid[sknIdx];
            info("First neighbor is %d on layer %d", sknID, SK_NeighNode.m_Layer);

      // Active and skewed
      if(  (SK_NeighNode.m_type == GridNode::STT_TYPE_SKEW) ) {
        // Current or next layer
        if( (SK_NeighNode.m_Layer == LocalCurrentLayer) ||
            (SK_NeighNode.m_Layer == LocalNextLayer) ) {
	  info("Is skewed and on next layer");
          FindIt = std::find(ListOfSkewedNodesIndex.begin(), ListOfSkewedNodesIndex.end(), sknIdx);
          // Was not added before
          if( FindIt == ListOfSkewedNodesIndex.end() ) {
            SkewedNodeIndexQueue.inQueue(sknIdx);
            ListOfSkewedNodesIndex.push_back(sknIdx);
          }// End If not added before
        }// Current or next layer
      }// END if active and skewed.
      // If neighbour node is a virtual node. We can start
      // correcting and computing the orientations.
      else if( (SK_NeighNode.m_type == GridNode::VIRTUAL_NODE) ) {
	info("Is virtual and on next layer");
	FindIt = std::find(ListOfVirtualNodesIndex.begin(), ListOfVirtualNodesIndex.end(), sknIdx);
	if( (FindIt == ListOfVirtualNodesIndex.end()) && (sknID != VNode.m_detID) ) {
	  // Outer -> inner layer
	  if( (OuterToInner) && (SK_NeighNode.m_Layer <= SK_Node.m_Layer)) {
	    ListOfVirtualNodesIndex.push_back(sknIdx);
	    LastVirtualNodeIdx = sknIdx;
	  }
	  // Inner -> outer layer
	  if( (!OuterToInner) && (SK_NeighNode.m_Layer >= SK_Node.m_Layer)) {
	    ListOfVirtualNodesIndex.push_back(sknIdx);
	    LastVirtualNodeIdx = sknIdx;
	  }
	}
      }// END if active and virtual
    }//END neighbour loop
  }//END WHILE (SkewedNodeIndexQueue)
  int lastVirtualID = -10;
  if (LastVirtualNodeIdx >= 0) {
    GridNode &LastVirtual_node = Ingrid[LastVirtualNodeIdx];
    lastVirtualID = LastVirtual_node.m_detID;
    /* A list of all skewed nodes between the two virtual nodes is
       created by now and we can proceed with corrections of the
       xy-coordinates. Determine the dx and dy between current node and
       last virtual node.*/
    float x_diff = fabs(VNode.m_x - LastVirtual_node.m_x);
    float y_diff = fabs(VNode.m_y - LastVirtual_node.m_y);
    x_diff /= static_cast<float>(ListOfSkewedNodesIndex.size()+1);
    y_diff /= static_cast<float>(ListOfSkewedNodesIndex.size()+1);
    if( VNode.m_x > LastVirtual_node.m_x ) {
      x_diff *= -1;
    }
    if( VNode.m_y > LastVirtual_node.m_y ) {
      y_diff *= -1;
    }
    ////__________________ DEBUG PRINTS ______________________________________
    std::cout << "<DEBUG>\tListOfSkewedNodesIndex.size() " << ListOfSkewedNodesIndex.size()
              << " ListOfVirtualNodesIndex " << ListOfVirtualNodesIndex.size()
              << " x_diff = " << x_diff << ", y_diff = " << y_diff
              << '\n';
    std::cout << " Starting from " << VNode.m_detID << "("<< VNode.m_Layer << "): ";
    for(size_t v = 0; v < ListOfVirtualNodesIndex.size(); ++v) {
      int indexof = ListOfVirtualNodesIndex[v];
      GridNode const &Vnd = Ingrid[indexof];
      std::cout << Vnd.m_detID << "("<< Vnd.m_Layer << "), ";
    }
    std::cout << " Last V_id = " << LastVirtual_node.m_detID << std::endl;
    ////__________________ DEBUG PRINTS ______________________________________
    float xInc = VNode.m_x + x_diff;
    float yInc = VNode.m_y + y_diff;
    /* Correct xy-coordinates of the skewed nodes */
    for(size_t m = 0; m < ListOfSkewedNodesIndex.size(); ++m) {
      GridNode &skewedToproc = Ingrid[ListOfSkewedNodesIndex[m]];
      skewedToproc.m_xDet = xInc;
      skewedToproc.m_yDet = yInc;
      xInc += x_diff;
      yInc += y_diff;
    }
  }
  /* Skewed nodes are pre-processed. RETURN*/
  return(lastVirtualID);
}


bool sortNeighbors(CoordGrid *gr, GridNode *currentNode, std::vector<int> *prev, std::vector<int> *same, std::vector<int> *next, std::vector<int> *virt, char *visited, int *dir){

  int curDir = *dir;
  std::vector< GridNode > &Ingrid = gr->m_grid;
  int curLayer = currentNode->m_Layer;
  int curId =  currentNode->m_detID;
  bool cond = true;

  std::vector<int>  ListOfSkewedNodesIndex;
  std::vector<int>  ListOfVirtualNodesIndex;
  for(int i = 0; i < currentNode->m_neighbors.size(); i++){
    int neighId = currentNode->m_neighbors[i];
    int neighIdx = gr->Find(neighId);
    GridNode *neighNode = &Ingrid[neighIdx];
    debug("Node %d has one neig %d", curId, neighId);
    if(neighNode->m_type == GridNode::VIRTUAL_NODE){
      virt->push_back(neighId);
      //   determineSkewed_XYPlane_perso( *gr, *neighNode, ListOfSkewedNodesIndex, ListOfVirtualNodesIndex,visited);
      //error("%d curlaye %d, virtual layer %d", neighId, curLayer, neighNode->m_Layer);
      continue;
      /*  debug("%d is a virtual node, add to list and find next neighbor", neighId);
      neighId    = neighNode->m_neighbors[0] == curId ?  neighNode->m_neighbors[1]: neighNode->m_neighbors[0];
      neighIdx   = gr->Find(neighId);
      neighNode  = &Ingrid[neighIdx];*/
    }	 

    if(visited[neighId] == 0){
      if(neighNode->m_Layer > curLayer){
	//	debug("Node %d has one neigh up %d", curId, neighId);
	next->push_back(neighId);
	curDir |= UP;
	visited[neighId] = 2;
      } else if( neighNode->m_Layer < curLayer) {
	//	debug("Node %d has one neigh down %d", curId, neighId);
	prev->push_back(neighId);
	curDir |= DOWN;
	visited[neighId] = 2;
      } else {
	//	debug("Node %d has one neigh on the same %d", curId, neighId);
	same->push_back(neighId);
	//	curDir |= SAME;
	visited[neighId] = 2;
      }
    } else if(visited[neighId] == 4){
      //   debug("Node %d has already been connected, tricky", neighId);
      cond = false;
      if(!(std::find(same->begin(), same->end(), neighId) != same->end()))
	same->push_back(neighId);

    }// else
     //  debug("Node %d has already been added, tricky", neighId);
  }

  	
  if( curDir > 4 || same->size() > 1){
    info("Too many possibilities, let skip it for now");
    cond = false;
  }
  *dir = curDir;

  return cond;
  
}

void resetLists(char *visited, std::vector<int> *prev, std::vector<int> *same, std::vector<int> *next){
  for (int i = 0; i < same->size(); i++)
    if(visited[same->at(i)]<4)
      visited[same->at(i)] =0;
	      
  for (int i = 0; i < next->size(); i++)
    if(visited[next->at(i)] < 4)
      visited[next->at(i)] =0;

  for (int i = 0; i < prev->size(); i++)
    if(visited[prev->at(i)] < 4)
      visited[prev->at(i)] =0;
}

void removeIdFromNeigh(GridNode *neighNode, std::vector<int> *prevNodes, int curId){
  for(int i = 0; i < prevNodes->size(); i++){
    if(prevNodes->at(i) != neighNode->m_detID){ 		
      (neighNode->m_neighbors).erase(std::remove((neighNode->m_neighbors).begin(), (neighNode->m_neighbors).end(),prevNodes->at(i)), (neighNode->m_neighbors).end());
      // debug("%d removed from  neighbor list of %d ",prevNodes->at(i), neighNode->m_detID);

      if(i == 0)
	neighNode->parent = curId;
    }
  }
}

bool areAdjacent(CoordGrid *gr, std::vector<int> *v){
  int adjacent = 0;
  std::vector< GridNode > &Ingrid = gr->m_grid;

  for (int i = 0; i < v->size(); i++){
    int neighId   = v->at(i);
    int neighIdx  = gr->Find(neighId);
    GridNode *neighNode = &Ingrid[neighIdx];
    //prevNodes.push_back(neighId);
    
    for (int j = i+1; j < v->size (); j++){
      //   debug("Are %d and %d connected?", neighId, v->at(j));
      if(neighId == v->at(j)) error("HOUSTON");
      else if(neighNode->IsNeighboring(v->at(j))){
	//	debug("Yes");
	adjacent++;
      }// else
      //	debug("No");
    }
  }
  
  if(adjacent >= v->size() -1)
    return true;
  else
    return false;
}


double *polyFit(std::vector<double>  x, std::vector<double>  y){
  int i,j,k,n,N;
  n = 2;
  double X[2*n+1];        //Array that will store the values of sigma(xi),sigma(xi^2),sigma(xi^3)....sigma(xi^2n)
  for (i=0;i<2*n+1;i++)
    {
      X[i]=0;
      for (j=0;j<x.size();j++)
	X[i]=X[i]+pow(x[j],i);        //consecutive positions of the array will store N,sigma(xi),sigma(xi^2),sigma(xi^3)....sigma(xi^2n)
    }
  double B[n+1][n+2];
  double *a = (double*)calloc(n+1, sizeof(double));//B is the Normal matrix(augmented) that will store the equations, 'a' is for value of the final coefficients
  for (i=0;i<=n;i++)
    for (j=0;j<=n;j++)
      B[i][j]=X[i+j];            //Build the Normal matrix by storing the corresponding coefficients at the right positions except the last column of the matrix
  double Y[n+1];                    //Array to store the values of sigma(yi),sigma(xi*yi),sigma(xi^2*yi)...sigma(xi^n*yi)
  for (i=0;i<n+1;i++)
    {    
      Y[i]=0;
      for (j=0;j<x.size();j++)
        Y[i]=Y[i]+pow(x[j],i)*y[j];        //consecutive positions will store sigma(yi),sigma(xi*yi),sigma(xi^2*yi)...sigma(xi^n*yi)
    }
  for (i=0;i<=n;i++)
    B[i][n+1]=Y[i];                //load the values of Y as the last column of B(Normal Matrix but augmented)
  n=n+1;                //n is made n+1 because the Gaussian Elimination part below was for n equations, but here n is the degree of polynomial and for n degree we get n+1 equations
  /*  cout<<"\nThe Normal(Augmented Matrix) is as follows:\n";    
  for (i=0;i<n;i++)            //print the Normal-augmented matrix
    {
      for (j=0;j<=n;j++)
	cout<<B[i][j]<<setw(16);
      cout<<"\n";
      }    */
  for (i=0;i<n;i++)                    //From now Gaussian Elimination starts(can be ignored) to solve the set of linear equations (Pivotisation)
    for (k=i+1;k<n;k++)
      if (B[i][i]<B[k][i])
	for (j=0;j<=n;j++)
	  {
	    double temp=B[i][j];
	    B[i][j]=B[k][j];
	    B[k][j]=temp;
	  }
     
  for (i=0;i<n-1;i++)            //loop to perform the gauss elimination
    for (k=i+1;k<n;k++)
      {
	double t=B[k][i]/B[i][i];
	for (j=0;j<=n;j++)
	  B[k][j]=B[k][j]-t*B[i][j];    //make the elements below the pivot elements equal to zero or elimnate the variables
      }
  for (i=n-1;i>=0;i--)                //back-substitution
    {                        //x is an array whose values correspond to the values of x,y,z..
      a[i]=B[i][n];                //make the variable to be calculated equal to the rhs of the last equation
      for (j=0;j<n;j++)
	if (j!=i)            //then subtract all the lhs values except the coefficient of the variable whose value                                   is being calculated
	  a[i]=a[i]-B[i][j]*a[j];
      a[i]=a[i]/B[i][i];            //now finally divide the rhs by the coefficient of the variable to be calculated
    }
   
  cout<<"The fitted Polynomial is given by:\ny=";
  for (i=0;i<n;i++)
    cout<<" + ("<<a[i]<<")"<<"x^"<<i;
  cout<<"\n";
  return a;
}

int returnDirection(double prev, double cur){
  double diff = cur - prev;
  int dir;
  if (diff > 1.)
    dir = 1;
  else if (diff < -1.)
    dir = -1;
  else
    dir = 0;


  return dir;
}


int fitnextId(CoordGrid &gr, std::vector<double> &x, std::vector<double> &y, std::vector<int> &next, int method){
  
  std::vector< GridNode > &Ingrid = gr.m_grid;

  if(method == 0){ // linear

  }  else if(method == 1){ // quadratic
    int xDir = returnDirection(  x[x.size()-2],  x[x.size()-1]);
    int yDir = returnDirection(  y[y.size()-2],  y[y.size()-1]);

    debug("We are going in x dir %d and y dir %d", xDir, yDir);

    double minDist = std::numeric_limits<double>::max();
    int goodId = -1;
    std::vector<double> p;
    p.push_back(0.);
    
    for (int i = 0; i < x.size() - 1; i++){
      double newval = p[i] + sqrt(pow(x[i+1]-x[i],2.) + pow(y[i+1]-y[i],2.));
      p.push_back(newval);
      // debug("%lf, %lf", p[i+1]);

    }


    double *x_coef = polyFit(p, x);
    double *y_coef = polyFit(p, y);

    for (int i = 0; i <next.size(); i++){
      int curId = next[i];
      int curIdx = gr.Find(curId);
      GridNode *node = &Ingrid[curIdx];
      double xdet = (double) node->m_xDet;
      double ydet = (double) node->m_yDet;

      double newx_coef[3] = {x_coef[0] - xdet, x_coef[1], x_coef[2]};
      double newy_coef[3] = {y_coef[0] - ydet, y_coef[1], y_coef[2]};

      double vectortanx[3] = {x_coef[1], 2*x_coef[2], 0.};
      double vectortany[3] = {y_coef[1], 2*y_coef[2], 0.};
	      
      double d[4] = {newx_coef[0]*vectortanx[0] + newy_coef[0]*vectortany[0],
		     newx_coef[0]*vectortanx[1] + newx_coef[1]*vectortanx[0] +
		     newy_coef[0]*vectortany[1] + newy_coef[1]*vectortany[0],
		     newx_coef[0]*vectortanx[2] + newx_coef[1]*vectortanx[1] + newx_coef[2]*vectortanx[0] +
		     newy_coef[0]*vectortany[2] + newy_coef[1]*vectortany[1] + newy_coef[2]*vectortany[0],
		     newx_coef[2]*vectortanx[1] + newy_coef[2]*vectortany[1]};

      double x0[3];
      int nroot = gsl_poly_solve_cubic(d[2]/d[3], d[1]/d[3], d[0]/d[3], x0, x0+1, x0+2);

      //debug("Polynomial coeff : %lf + %lf x + %lf x^2 + %lf x^3", d[0], d[1], d[2], d[3]);
      //	debug("Real roots %d : x1 = %lf x2 =  %lf x3 =  %lf \n\n", nroot, x0[0], x0[1], x0[2]);

      double xIntersect, yIntersect, currDist;
      if(nroot ==1){
	xIntersect = gsl_poly_eval(x_coef, 3, x0[0]);
	yIntersect = gsl_poly_eval(y_coef, 3, x0[0]);
	currDist = sqrt(pow(xIntersect - xdet,2) + pow(yIntersect - ydet,2));
      }

		
      for (int j = 0; j < nroot; j++){
	double newx = gsl_poly_eval(x_coef, 3, x0[j]);
	double newy = gsl_poly_eval(y_coef, 3, x0[j]);
	double newdist = sqrt(pow(newx - xdet,2) + pow(newy - ydet,2));
	if(j == 0){
	  xIntersect = newx;
	  yIntersect = newy;
	  currDist = newdist;
	} else if( currDist > newdist) {
	  xIntersect = newx;
	  yIntersect = newy;
	  currDist = newdist;
	}
      }

      debug("Distance between point %d and fit is %lf", curId, currDist);
      // double disttube = distanceBetweenTube(node, lastNode);
      //debug("Tube Distance to point %d is %lf",curId, disttube);


      int newxDir = returnDirection(  x[x.size()-1], xdet);
      int newyDir = returnDirection(  y[y.size()-1], ydet);

      debug("This node is in x dir %d and y dir %d", newxDir, newyDir);

		
      if(minDist > currDist){
	if(labs(newxDir - xDir) > 1 || labs(newyDir - yDir) > 1){
	  debug("Let's avoid going back if we can");
	} else{
		    
	  minDist = currDist;
		  
	  goodId = curId;
	  //goodNode = ;
	}
      }
	    
		
    } // FOR RIGHT NEIGHBORS
    info("The good id is %d, and is at distance %lf", goodId,minDist);
    return goodId;

  }  

  return -1;
}


